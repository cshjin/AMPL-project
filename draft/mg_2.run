#----------------------------------------
# FARMAR RUN COMMEND
#----------------------------------------

reset;
option solver gurobi;
option presolve 1;
# option cplex_options 'sensitivity';
option precision 4;
#option show_stats 1;
include mg_2.mod;
include mg_2.dat;

read {t in Time} WindSpeed[t] < WindSpeed.txt;
read {t in Time} CoolingDegreeHours[t] < CoolingDegreeHours.txt;
read {t in Time} HeatDegreeHours[t] < HeatDegreeHours.txt;
read {t in Time} CloudOvercastPercentage[t] < CloudOvercastPercentage.txt;
read {t in Time} SolarRadi[t] < SolarRadi.txt;
read {t in Time} StateSequence[t] < StateSequence.txt;
read {t in Time} Buying[t] < BuyingPrice.txt;
read {t in Time} Selling[t] < SellingPrice.txt;
read {t in Time} DemandSeq[t] < Demand.txt;
read {t in Time} ResourcesSeq[t] < Resources.txt;

## one approach
for { t in 1..SIZE-1 by 2} {
#	let Demand := HeatDegreeHours[t]*1000+CoolingDegreeHours[t]*1000
#				+ Uniform(500,5000);
#	let Resources := 0.5 * 0.5 * 5 * 5 * 1.27 * Pi
#				* WindSpeed[t] * WindSpeed[t] * WindSpeed[t] 
#				+ 1.2 * 100 * SolarRadi[t] * (1- CloudOvercastPercentage[t]);
	let Demand := DemandSeq[t];
	let Resources := ResourcesSeq[t];

	# change probability of each stage
	if StateSequence[t] = 1 # N
		then {
			let P["N"]:= 0.7;
			let P["A"]:= 0.2;
			let P["M"]:= 0.1;
		}
	else if StateSequence[t] = 2 # A
		then {
			let P["N"]:= 0.6;
			let P["A"]:= 0.3;
			let P["M"]:= 0.1;
		}
	else if StateSequence[t] = 3 # M
		then {
			let P["N"]:= 0.5;
			let P["A"]:= 0.4;
			let P["M"]:= 0.1;
		};

	let BuyingPrice := Buying[t];
	let SellingPrice := Selling[t];
	# print Buying[t+1];
	let BuyingPrice_stage := Buying[t+1 mod SIZE];
	let SellingPrice_stage := Selling[t+1 mod SIZE];
	let Demand_stage := DemandSeq[t+1 mod SIZE];
	let Resources_stage["N"] := ResourcesSeq[t+1 mod SIZE];
	let Resources_stage["A"] := ResourcesSeq[t+1 mod SIZE]/2;
	let Resources_stage["M"] := ResourcesSeq[t+1 mod SIZE]/4;

	print t > mg_2.out;
	solve;
	display TransitionPrice * (amount['BC']+amount['BG']
		+amount['GB']+amount['RB']) +
	ReservePrice * (InitBattery-amount['BC'] - amount['BG']
		+amount['GB']+amount['RB']) +
	BuyingPrice * (amount['GB'] + amount['GC']) -
	SellingPrice * (amount['BG'] + amount['RG']) >mg_2.out;
	# display sum {s in Scenarios} 
	if StateSequence[t+1] = 1
		then {
			display (
		TransitionPrice * (
			amount_stage['BC','N']
			+amount_stage['BG','N']
			+amount_stage['GB','N']
			+amount_stage['RB','N']) +
		ReservePrice * (
			InitBattery
			-amount['BC'] 
			-amount['BG']
			+amount['GB']
			+amount['RB'] 
			-amount_stage['BC','N']
			-amount_stage['BG','N']
			+amount_stage['GB','N']
			+amount_stage['RB','N']) +
		BuyingPrice_stage * (
			amount_stage['GB','N'] 
			+ amount_stage['GC','N']) -
		SellingPrice_stage * (
			amount_stage['BG','N'] 
			+ amount_stage['RG','N'])) > mg_2.out;
		}
	else if StateSequence[t+1] = 2 # A
		then {
			display (
		TransitionPrice * (
			amount_stage['BC','A']
			+amount_stage['BG','A']
			+amount_stage['GB','A']
			+amount_stage['RB','A']) +
		ReservePrice * (
			InitBattery
			-amount['BC'] 
			-amount['BG']
			+amount['GB']
			+amount['RB'] 
			-amount_stage['BC','A']
			-amount_stage['BG','A']
			+amount_stage['GB','A']
			+amount_stage['RB','A']) +
		BuyingPrice_stage * (
			amount_stage['GB','A'] 
			+ amount_stage['GC','A']) -
		SellingPrice_stage * (
			amount_stage['BG','A'] 
			+ amount_stage['RG','A'])) > mg_2.out;
		}
	else if StateSequence[t+1] = 3 # M
		then {
			display (
		TransitionPrice * (
			amount_stage['BC','M']
			+amount_stage['BG','M']
			+amount_stage['GB','M']
			+amount_stage['RB','M']) +
		ReservePrice * (
			InitBattery
			-amount['BC'] 
			-amount['BG']
			+amount['GB']
			+amount['RB'] 
			-amount_stage['BC','M']
			-amount_stage['BG','M']
			+amount_stage['GB','M']
			+amount_stage['RB','M']) +
		BuyingPrice_stage * (
			amount_stage['GB','M'] 
			+ amount_stage['GC','M']) -
		SellingPrice_stage * (
			amount_stage['BG','M'] 
			+ amount_stage['RG','M'])) > mg_2.out;
		};
	display _objname, _obj > mg_2.out;
	# display _objname, _obj > mg_2.out;
	# Print out the value of the objective function 
	# display _varname, _var, _var.lb,_var.ub, _var.rc > mg_2.out;
	# Print out names, values and reduced costs 
#	display _varname, _var.down, _var.current, _var.up > mg_2.out;
	# Print out names, objective function coefficients 
	# together with what can be changed without causing 
	# a base change 
	# down = lower limit, up = upper limit 
#	display _conname, _con.slack, _con.dual > mg_2.out;
	# Print out constraint name, slack and shadow price 
#	display _conname,_con.down,_con.current,_con.up > mg_2.out;
	# Print out constraint name, right-hand side coefficient 
	# together with what can be changed without causing 
	# a base change 
	
#	reset some parameters to solve it repeately
	let InitBattery := InitBattery 
						+ amount['GB'] + amount['RB'] 
						- amount['BG'] - amount['BC'];
}

## another approach
#for {t in 1..SIZE-1}{
	# similar
#}

# steady-state probabilities
#let P["N"]:= 0.656;
#let P["A"]:= 0.244;
#let P["M"]:= 0.1;
#let BuyingPrice := Buying[t];
#let SellingPrice := Selling[t];
#let BuyingPrice_stage := Buying[{t+1 mod SIZE}];
#let SellingPrice_stage := Selling[{t+1 mod SIZE}];
#let Demand_stage := DemandSeq[t+1 mod SIZE];
#let Resources_stage["N"]:=ResourcesSeq[{t+1 mod SIZE}];
#let Resources_stage["A"]:=ResourcesSeq[{t+1 mod SIZE]/2;
#let Resources_stage["M"]:=ResourcesSeq[{t+1 mod SIZE}]/4;